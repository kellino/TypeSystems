
==================== FINAL INTERFACE ====================
2017-03-27 13:38:00.295483556 UTC

interface main@main:StaticCheck 8002
  interface hash: 5832dceda1e405b2de1d33c5e54adcf6
  ABI hash: 76ee07f7ee9c5e7c47f4f2c01d7d7993
  export-list hash: 48acd9757feac4c8aa023e053977c156
  orphan hash: d523581dda491571d3a8b3c5254c6742
  flag hash: ab18c854513203f52daeb6698cb70ffd
  sig of: Nothing
  used TH splices: False
  where
exports:
  StaticCheck.checkStatic
  StaticCheck.getLabel
  StaticCheck.gradJoin
  StaticCheck.gradMeet
  StaticCheck.inEnv
  StaticCheck.isGradSubTypeOf
  StaticCheck.lookupVar
  StaticCheck.runOverFile
  StaticCheck.runStatic
  StaticCheck.setLabel
  StaticCheck.StaticType
module dependencies: Gamma Lattice Syntax
package dependencies: StateVar-1.1.0.4@StateVar-1.1.0.4-5dJbnTVECtEAhfJXPZKdbO
                      array-0.5.1.1@array-0.5.1.1 base-4.9.1.0
                      base-orphans-0.5.4@base-orphans-0.5.4-ABoxiBf7nXc7Qqh66CgYc9
                      bifunctors-5.4.1@bifunctors-5.4.1-G9sSLclb5k26O3Lio1becS
                      comonad-5@comonad-5-3taBO7oiJOm7HwkDYjek6x
                      containers-0.5.7.1@containers-0.5.7.1
                      contravariant-1.4@contravariant-1.4-LOqCz9UiRqn89oyERzBA9D
                      deepseq-1.4.2.0@deepseq-1.4.2.0
                      distributive-0.5.2@distributive-0.5.2-DzhYIvhMV8O6K3jnVc2kgn
                      ghc-prim-0.5.0.0 integer-gmp-1.0.0.1
                      mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6
                      profunctors-5.2@profunctors-5.2-LIxTI75q4uF48YzuBFpJUP
                      stm-2.4.4.1@stm-2.4.4.1-JQn4hNPyYjP5m9AcbI88Ve
                      tagged-0.8.5@tagged-0.8.5-DqTYAPqU3ao5zvndQftjsL
                      transformers-0.5.2.0@transformers-0.5.2.0
                      transformers-compat-0.5.1.4@transformers-compat-0.5.1.4-2tm9ddmq5Qk3kF2emBuYBK
                      unbound-generics-0.3.1@unbound-generics-0.3.1-BnZfdHaJ5Vovbu7cNDG2E
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         main@main:Syntax
         stm-2.4.4.1@stm-2.4.4.1-JQn4hNPyYjP5m9AcbI88Ve:Control.Monad.STM
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Complex base-4.9.1.0:Data.Either
                         base-4.9.1.0:Data.Functor.Compose base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.Functor.Product base-4.9.1.0:Data.Functor.Sum
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         bifunctors-5.4.1@bifunctors-5.4.1-G9sSLclb5k26O3Lio1becS:Data.Bifunctor.Biff
                         bifunctors-5.4.1@bifunctors-5.4.1-G9sSLclb5k26O3Lio1becS:Data.Bifunctor.Clown
                         bifunctors-5.4.1@bifunctors-5.4.1-G9sSLclb5k26O3Lio1becS:Data.Bifunctor.Joker
                         bifunctors-5.4.1@bifunctors-5.4.1-G9sSLclb5k26O3Lio1becS:Data.Bifunctor.Product
                         bifunctors-5.4.1@bifunctors-5.4.1-G9sSLclb5k26O3Lio1becS:Data.Bifunctor.Sum
                         bifunctors-5.4.1@bifunctors-5.4.1-G9sSLclb5k26O3Lio1becS:Data.Bifunctor.Tannen
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
                         main@main:Lattice main@main:Syntax
                         tagged-0.8.5@tagged-0.8.5-DqTYAPqU3ao5zvndQftjsL:Data.Tagged
                         unbound-generics-0.3.1@unbound-generics-0.3.1-BnZfdHaJ5Vovbu7cNDG2E:Unbound.Generics.LocallyNameless.Bind
                         unbound-generics-0.3.1@unbound-generics-0.3.1-BnZfdHaJ5Vovbu7cNDG2E:Unbound.Generics.LocallyNameless.Embed
                         unbound-generics-0.3.1@unbound-generics-0.3.1-BnZfdHaJ5Vovbu7cNDG2E:Unbound.Generics.LocallyNameless.Name
                         unbound-generics-0.3.1@unbound-generics-0.3.1-BnZfdHaJ5Vovbu7cNDG2E:Unbound.Generics.LocallyNameless.Rebind
                         unbound-generics-0.3.1@unbound-generics-0.3.1-BnZfdHaJ5Vovbu7cNDG2E:Unbound.Generics.LocallyNameless.Rec
                         unbound-generics-0.3.1@unbound-generics-0.3.1-BnZfdHaJ5Vovbu7cNDG2E:Unbound.Generics.LocallyNameless.Shift
import  -/  base-4.9.1.0:Data.Either 20b09ef8d0a5b74fdec011c40c1587f5
import  -/  base-4.9.1.0:Data.Functor.Identity 6ee67943d44d50091e12d22df04741f0
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.Err 3bba35a16538d33d424682ce66876cdd
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Map 20d4ffbee41965d03d6a989425473dc4
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base a29df8c78ba14cbcd4d90f97bd8d22e9
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  Gamma 4aeb18cf8fa74d68a048d0751b385c8b
  exports: 3977cd7b93c438541904e8bef23fa46c
  extendGamma d58a18f0fcb0db40a4ae72cd12f0c643
  remove 014d2df0184c4e2db638513180e8348d
import  -/  Lattice 88fcd7154be3313c1d1dd4a146e11a7c
  exports: 495e954e0fa964baf836dbc63274531d
  /\ 0568deb64208c2eeba28e59ca38a40dd
  GLabel 9052b3c150b0d7c7ae0110d0be5cae63
  \/ 9b8f3f29635afe944e512ee9288b7366
  flowsTo 9c40cd6c1ef3a35d54099930529a2a8f
import  -/  Syntax 6c120300cbc8be0c354432ee47bcf2aa
  exports: 095bc84ec11cd23a65bba080dc14ddf8
  Annot 221379c6c4d890ad080299c4d1880646
  App 5b715b32b70eb55e4256cd177256255d
  Binding 1c00495f8b82fdc5f4b94a20ffa4f358
  Ctx 043451a54ebe0fa8e1aabda3008751fa
  GType 9e345476bfbabb6a0c691ef7bb32faa9
  Gamma b049cc93227a1c99c7e5e3557f91a45a
  IfThenElse e6feaeb57d26d6c6647f3942b1a7749c
  ImplicitFlow 3871535f9a122afa88e42dad12eb7df4
  Lam 5b34c8f833ff2c9c793f866b9d302718
  NotInScope 7b66af2f5a6e20202e03f19311f4190d
  Op 01ccf73c5362f4208b5f138298f072ad
  Term 6ebfa21d5709e4d46af7a40bb888ccd3
  TyArr f95d38d00330e797c76cd27e4cdb6a9f
  TyBool 8b0de33e7c2d539007e38a69af0404f1
  TypeError dc1095d87eb0bdc7005db148b0dbc7c9
  Undefined 37d82c9b65d14f3c8a42d1e505fa7763
  Val 4410c99ba37d58e1d0c9996a4dd07a70
  Var 8e5fdac9870ed392f8c34cbea521782e
  gamma 8ae791ea92a1337073c6a69aa8e4787c
import  -/  mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6:Control.Monad.Error.Class 635294424a2da8269902789f5c8bbe99
import  -/  mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6:Control.Monad.Except 3bb0e2598193c1ba00c9723945e93004
import  -/  mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6:Control.Monad.Identity 40aa39339177ff1862f1070dc676c5be
import  -/  mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6:Control.Monad.Reader 0a25f5000d6974b16ed96a739eacaeb6
import  -/  mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6:Control.Monad.Reader.Class 9573b8d2ba4bcf8261d19527e0170c4d
import  -/  transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Except cf549ed58fbe6804d519833d92803f4c
import  -/  transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Reader 1b607a084a390ae0e50e8f8dcbf2541a
import  -/  unbound-generics-0.3.1@unbound-generics-0.3.1-BnZfdHaJ5Vovbu7cNDG2E:Unbound.Generics.LocallyNameless a8a69671ee3f84c700f8a6297dd8e653
import  -/  unbound-generics-0.3.1@unbound-generics-0.3.1-BnZfdHaJ5Vovbu7cNDG2E:Unbound.Generics.LocallyNameless.Fresh 91f6fcaf3f01e0581cd98409127e3fe6
import  -/  unbound-generics-0.3.1@unbound-generics-0.3.1-BnZfdHaJ5Vovbu7cNDG2E:Unbound.Generics.LocallyNameless.Name 1c2f72bd3f4b997ab8a55e423aaf2370
import  -/  unbound-generics-0.3.1@unbound-generics-0.3.1-BnZfdHaJ5Vovbu7cNDG2E:Unbound.Generics.LocallyNameless.Operations 7bcf476ae4d7b1b04d0e51499f1ea789
3cd34e7fdcc965d89650d9ca3ce05ff2
  $s$fApplicativeExceptT ::
    GHC.Base.Applicative
      (Control.Monad.Trans.Except.ExceptT
         e Data.Functor.Identity.Identity)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ e.
                  @ (Control.Monad.Trans.Except.ExceptT
                       e Data.Functor.Identity.Identity)
                  (StaticCheck.$s$fApplicativeExceptT1 @ e)
                  (StaticCheck.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$cpure
                     @ e)
                  (Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                     @ Data.Functor.Identity.Identity
                     @ e
                     StaticCheck.$s$fApplicativeExceptT_$dFunctor
                     Data.Functor.Identity.$fMonadIdentity)
                  (Control.Monad.Trans.Except.$fApplicativeExceptT_$c*>
                     @ Data.Functor.Identity.Identity
                     @ e
                     StaticCheck.$s$fApplicativeExceptT_$dFunctor
                     Data.Functor.Identity.$fMonadIdentity)
                  (Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*
                     @ Data.Functor.Identity.Identity
                     @ e
                     StaticCheck.$s$fApplicativeExceptT_$dFunctor
                     Data.Functor.Identity.$fMonadIdentity) -}
404ba8ffbe4623dc5d3e261462aa89da
  $s$fApplicativeExceptT1 ::
    GHC.Base.Functor
      (Control.Monad.Trans.Except.ExceptT
         e Data.Functor.Identity.Identity)
  {- Unfolding: (\ @ e ->
                 Control.Monad.Trans.Except.$fFunctorExceptT
                   @ Data.Functor.Identity.Identity
                   @ e
                   Data.Functor.Identity.$fFunctorIdentity) -}
a47ab957e29c53b4540cbac7db100cbd
  $s$fApplicativeExceptT_$dFunctor ::
    GHC.Base.Functor Data.Functor.Identity.Identity
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                Data.Functor.Identity.$fFunctorIdentity -}
d6436d22477db615baf2df7da843706e
  $s$fApplicativeExceptT_$s$fApplicativeExceptT_$cpure ::
    a
    -> Control.Monad.Trans.Except.ExceptT
         e Data.Functor.Identity.Identity a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ e @ a (a1 :: a) ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (Data.Functor.Identity.Identity (Data.Either.Either e a))
                   @ (Control.Monad.Trans.Except.ExceptT
                        e Data.Functor.Identity.Identity a)
                   (\ (tpl :: Data.Functor.Identity.Identity
                                (Data.Either.Either e a)) ->
                    tpl)
                     `cast`
                   (<Data.Functor.Identity.Identity (Data.Either.Either e a)>_R
                    ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                  <e>_N <Data.Functor.Identity.Identity>_R <a>_N))
                   (Data.Functor.Identity.$fApplicativeIdentity_$cpure
                      @ (Data.Either.Either e a)
                      (Data.Either.Right @ e @ a a1))) -}
63bbf9b32f57a0a690f6e3e52f9a4e45
  $s$fApplicativeFreshMT ::
    GHC.Base.Applicative
      (Unbound.Generics.LocallyNameless.Fresh.FreshMT
         (Control.Monad.Trans.Reader.ReaderT
            Syntax.Ctx
            (Control.Monad.Trans.Except.ExceptT
               Syntax.TypeError Data.Functor.Identity.Identity)))
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Fresh.FreshMT
                       (Control.Monad.Trans.Reader.ReaderT
                          Syntax.Ctx
                          (Control.Monad.Trans.Except.ExceptT
                             Syntax.TypeError Data.Functor.Identity.Identity)))
                  StaticCheck.$s$fApplicativeFreshMT_$s$fApplicativeFreshMT_$cp1Applicative
                  (Unbound.Generics.LocallyNameless.Fresh.$fApplicativeFreshMT_$cpure
                     @ (Control.Monad.Trans.Reader.ReaderT
                          Syntax.Ctx
                          (Control.Monad.Trans.Except.ExceptT
                             Syntax.TypeError Data.Functor.Identity.Identity))
                     StaticCheck.$s$fApplicativeFreshMT1)
                  (Unbound.Generics.LocallyNameless.Fresh.$fApplicativeFreshMT_$c<*>
                     @ (Control.Monad.Trans.Reader.ReaderT
                          Syntax.Ctx
                          (Control.Monad.Trans.Except.ExceptT
                             Syntax.TypeError Data.Functor.Identity.Identity))
                     StaticCheck.$s$fApplicativeFreshMT1)
                  (Unbound.Generics.LocallyNameless.Fresh.$fApplicativeFreshMT_$c*>
                     @ (Control.Monad.Trans.Reader.ReaderT
                          Syntax.Ctx
                          (Control.Monad.Trans.Except.ExceptT
                             Syntax.TypeError Data.Functor.Identity.Identity))
                     StaticCheck.$s$fApplicativeFreshMT1)
                  (Unbound.Generics.LocallyNameless.Fresh.$fApplicativeFreshMT_$c<*
                     @ (Control.Monad.Trans.Reader.ReaderT
                          Syntax.Ctx
                          (Control.Monad.Trans.Except.ExceptT
                             Syntax.TypeError Data.Functor.Identity.Identity))
                     StaticCheck.$s$fApplicativeFreshMT1) -}
27dd1cfe7b9b367e5f38d4164b451636
  $s$fApplicativeFreshMT1 ::
    GHC.Base.Monad
      (Control.Monad.Trans.Reader.ReaderT
         Syntax.Ctx
         (Control.Monad.Trans.Except.ExceptT
            Syntax.TypeError Data.Functor.Identity.Identity))
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                (StaticCheck.$s$fApplicativeFreshMT_$s$fMonadReaderT
                   @ Syntax.Ctx) -}
d6c3bd0d26d5615040f913430d2a9f36
  $s$fApplicativeFreshMT_$dApplicative ::
    GHC.Base.Applicative
      (Control.Monad.Trans.Except.ExceptT
         Syntax.TypeError Data.Functor.Identity.Identity)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                (StaticCheck.$s$fApplicativeExceptT @ Syntax.TypeError) -}
a255ad197d9f70902e9ab6a28b08780c
  $s$fApplicativeFreshMT_$dFunctor ::
    GHC.Base.Functor
      (Control.Monad.Trans.Reader.ReaderT
         Syntax.Ctx
         (Control.Monad.Trans.Except.ExceptT
            Syntax.TypeError Data.Functor.Identity.Identity))
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                (StaticCheck.$s$fApplicativeFreshMT_$s$fFunctorReaderT
                   @ Syntax.Ctx) -}
06cf9a3e379bcd7866de877c4152a6f2
  $s$fApplicativeFreshMT_$s$fApplicativeFreshMT_$cp1Applicative ::
    GHC.Base.Functor
      (Unbound.Generics.LocallyNameless.Fresh.FreshMT
         (Control.Monad.Trans.Reader.ReaderT
            Syntax.Ctx
            (Control.Monad.Trans.Except.ExceptT
               Syntax.TypeError Data.Functor.Identity.Identity)))
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                StaticCheck.$s$fApplicativeFreshMT_$s$fFunctorFreshMT -}
0c25c229c5ff0dd97fd4f8112f25c42a
  $s$fApplicativeFreshMT_$s$fApplicativeReaderT ::
    GHC.Base.Applicative
      (Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Syntax.TypeError Data.Functor.Identity.Identity))
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ r.
                  @ (Control.Monad.Trans.Reader.ReaderT
                       r
                       (Control.Monad.Trans.Except.ExceptT
                          Syntax.TypeError Data.Functor.Identity.Identity))
                  (StaticCheck.$s$fApplicativeFreshMT_$s$fApplicativeReaderT_$cp1Applicative
                     @ r)
                  (\ @ a (eta :: a) ->
                   let {
                     m1 :: Control.Monad.Trans.Except.ExceptT
                             Syntax.TypeError Data.Functor.Identity.Identity a
                     = GHC.Base.$
                         @ 'GHC.Types.PtrRepLifted
                         @ (Data.Functor.Identity.Identity
                              (Data.Either.Either Syntax.TypeError a))
                         @ (Control.Monad.Trans.Except.ExceptT
                              Syntax.TypeError Data.Functor.Identity.Identity a)
                         (\ (tpl :: Data.Functor.Identity.Identity
                                      (Data.Either.Either Syntax.TypeError a)) ->
                          tpl)
                           `cast`
                         (<Data.Functor.Identity.Identity
                             (Data.Either.Either Syntax.TypeError a)>_R
                          ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                        <Syntax.TypeError>_N
                                        <Data.Functor.Identity.Identity>_R
                                        <a>_N))
                         (Data.Functor.Identity.$fApplicativeIdentity_$cpure
                            @ (Data.Either.Either Syntax.TypeError a)
                            (Data.Either.Right @ Syntax.TypeError @ a eta))
                   } in
                   (\ (eta3 :: r) ->
                    GHC.Base.const
                      @ (Control.Monad.Trans.Except.ExceptT
                           Syntax.TypeError Data.Functor.Identity.Identity a)
                      @ r
                      m1
                      eta3)
                     `cast`
                   (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                             <*>_N
                             <r>_R
                             <Control.Monad.Trans.Except.ExceptT
                                Syntax.TypeError Data.Functor.Identity.Identity>_R
                             <a>_N)))
                  (StaticCheck.$s$fApplicativeFreshMT_$s$fApplicativeReaderT_$c<*>
                     @ r)
                  (Control.Monad.Trans.Reader.$fApplicativeReaderT_$c*>
                     @ (Control.Monad.Trans.Except.ExceptT
                          Syntax.TypeError Data.Functor.Identity.Identity)
                     @ r
                     StaticCheck.$s$fApplicativeFreshMT_$dApplicative)
                  (Control.Monad.Trans.Reader.$fApplicativeReaderT_$c<*
                     @ (Control.Monad.Trans.Except.ExceptT
                          Syntax.TypeError Data.Functor.Identity.Identity)
                     @ r
                     StaticCheck.$s$fApplicativeFreshMT_$dApplicative) -}
3201406b00b9a0dfb378f8cee3a2763f
  $s$fApplicativeFreshMT_$s$fApplicativeReaderT_$c<*> ::
    Control.Monad.Trans.Reader.ReaderT
      r
      (Control.Monad.Trans.Except.ExceptT
         Syntax.TypeError Data.Functor.Identity.Identity)
      (a -> b)
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Syntax.TypeError Data.Functor.Identity.Identity)
         a
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Syntax.TypeError Data.Functor.Identity.Identity)
         b
  {- Arity: 3, Strictness: <L,1*C1(U)><L,1*C1(U)><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ r
                   @ a
                   @ b
                   (f :: Control.Monad.Trans.Reader.ReaderT
                           r
                           (Control.Monad.Trans.Except.ExceptT
                              Syntax.TypeError Data.Functor.Identity.Identity)
                           (a -> b))
                   (v :: Control.Monad.Trans.Reader.ReaderT
                           r
                           (Control.Monad.Trans.Except.ExceptT
                              Syntax.TypeError Data.Functor.Identity.Identity)
                           a) ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (r
                      -> Control.Monad.Trans.Except.ExceptT
                           Syntax.TypeError Data.Functor.Identity.Identity b)
                   @ (Control.Monad.Trans.Reader.ReaderT
                        r
                        (Control.Monad.Trans.Except.ExceptT
                           Syntax.TypeError Data.Functor.Identity.Identity)
                        b)
                   (\ (tpl :: r
                              -> Control.Monad.Trans.Except.ExceptT
                                   Syntax.TypeError Data.Functor.Identity.Identity b) ->
                    tpl)
                     `cast`
                   (<r
                     -> Control.Monad.Trans.Except.ExceptT
                          Syntax.TypeError Data.Functor.Identity.Identity b>_R
                    ->_R Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                  <*>_N
                                  <r>_R
                                  <Control.Monad.Trans.Except.ExceptT
                                     Syntax.TypeError Data.Functor.Identity.Identity>_R
                                  <b>_N))
                   (\ (r1 :: r) ->
                    Control.Monad.Trans.Except.$fApplicativeExceptT_$c<*>
                      @ Data.Functor.Identity.Identity
                      @ Syntax.TypeError
                      StaticCheck.$s$fApplicativeExceptT_$dFunctor
                      Data.Functor.Identity.$fMonadIdentity
                      @ a
                      @ b
                      (Control.Monad.Trans.Reader.runReaderT
                         @ r
                         @ *
                         @ (Control.Monad.Trans.Except.ExceptT
                              Syntax.TypeError Data.Functor.Identity.Identity)
                         @ (a -> b)
                         f
                         r1)
                      (Control.Monad.Trans.Reader.runReaderT
                         @ r
                         @ *
                         @ (Control.Monad.Trans.Except.ExceptT
                              Syntax.TypeError Data.Functor.Identity.Identity)
                         @ a
                         v
                         r1))) -}
d307a245719de363c17cd3e9136cc6dd
  $s$fApplicativeFreshMT_$s$fApplicativeReaderT_$cp1Applicative ::
    GHC.Base.Functor
      (Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Syntax.TypeError Data.Functor.Identity.Identity))
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                StaticCheck.$s$fApplicativeFreshMT_$s$fFunctorReaderT -}
9dbffe12e23a2ed79d79f60ba6ef252f
  $s$fApplicativeFreshMT_$s$fApplicativeReaderT_$cpure ::
    a
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Syntax.TypeError Data.Functor.Identity.Identity)
         a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m2,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ @ r @ a (eta :: a) ->
                 let {
                   m1 :: Control.Monad.Trans.Except.ExceptT
                           Syntax.TypeError Data.Functor.Identity.Identity a
                   = GHC.Base.$
                       @ 'GHC.Types.PtrRepLifted
                       @ (Data.Functor.Identity.Identity
                            (Data.Either.Either Syntax.TypeError a))
                       @ (Control.Monad.Trans.Except.ExceptT
                            Syntax.TypeError Data.Functor.Identity.Identity a)
                       (\ (tpl :: Data.Functor.Identity.Identity
                                    (Data.Either.Either Syntax.TypeError a)) ->
                        tpl)
                         `cast`
                       (<Data.Functor.Identity.Identity
                           (Data.Either.Either Syntax.TypeError a)>_R
                        ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                      <Syntax.TypeError>_N
                                      <Data.Functor.Identity.Identity>_R
                                      <a>_N))
                       (Data.Functor.Identity.$fApplicativeIdentity_$cpure
                          @ (Data.Either.Either Syntax.TypeError a)
                          (Data.Either.Right @ Syntax.TypeError @ a eta))
                 } in
                 (\ (eta3 :: r) ->
                  GHC.Base.const
                    @ (Control.Monad.Trans.Except.ExceptT
                         Syntax.TypeError Data.Functor.Identity.Identity a)
                    @ r
                    m1
                    eta3)
                   `cast`
                 (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                           <*>_N
                           <r>_R
                           <Control.Monad.Trans.Except.ExceptT
                              Syntax.TypeError Data.Functor.Identity.Identity>_R
                           <a>_N))) -}
cfe5d46ffe0b1bab062b5197c49e32eb
  $s$fApplicativeFreshMT_$s$fFunctorFreshMT ::
    GHC.Base.Functor
      (Unbound.Generics.LocallyNameless.Fresh.FreshMT
         (Control.Monad.Trans.Reader.ReaderT
            Syntax.Ctx
            (Control.Monad.Trans.Except.ExceptT
               Syntax.TypeError Data.Functor.Identity.Identity)))
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Fresh.FreshMT
                       (Control.Monad.Trans.Reader.ReaderT
                          Syntax.Ctx
                          (Control.Monad.Trans.Except.ExceptT
                             Syntax.TypeError Data.Functor.Identity.Identity)))
                  (Unbound.Generics.LocallyNameless.Fresh.$fFunctorFreshMT_$cfmap
                     @ (Control.Monad.Trans.Reader.ReaderT
                          Syntax.Ctx
                          (Control.Monad.Trans.Except.ExceptT
                             Syntax.TypeError Data.Functor.Identity.Identity))
                     StaticCheck.$s$fApplicativeFreshMT_$dFunctor)
                  (Unbound.Generics.LocallyNameless.Fresh.$fFunctorFreshMT_$c<$
                     @ (Control.Monad.Trans.Reader.ReaderT
                          Syntax.Ctx
                          (Control.Monad.Trans.Except.ExceptT
                             Syntax.TypeError Data.Functor.Identity.Identity))
                     StaticCheck.$s$fApplicativeFreshMT_$dFunctor) -}
1cdabf0dee3720785e13bf6d2a6f21e2
  $s$fApplicativeFreshMT_$s$fFunctorReaderT ::
    GHC.Base.Functor
      (Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Syntax.TypeError Data.Functor.Identity.Identity))
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ r.
                  @ (Control.Monad.Trans.Reader.ReaderT
                       r
                       (Control.Monad.Trans.Except.ExceptT
                          Syntax.TypeError Data.Functor.Identity.Identity))
                  (StaticCheck.$s$fApplicativeFreshMT_$s$fFunctorReaderT_$cfmap @ r)
                  (StaticCheck.$s$fApplicativeFreshMT_$s$fFunctorReaderT_$c<$ @ r) -}
14dda943555cf27f7438f7325ed8fd15
  $s$fApplicativeFreshMT_$s$fFunctorReaderT_$c<$ ::
    a
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Syntax.TypeError Data.Functor.Identity.Identity)
         b
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Syntax.TypeError Data.Functor.Identity.Identity)
         a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><C(S),1*C1(U)><L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ r @ a @ b (eta :: a) ->
                 Control.Monad.Trans.Reader.mapReaderT
                   @ *
                   @ *
                   @ (Control.Monad.Trans.Except.ExceptT
                        Syntax.TypeError Data.Functor.Identity.Identity)
                   @ b
                   @ (Control.Monad.Trans.Except.ExceptT
                        Syntax.TypeError Data.Functor.Identity.Identity)
                   @ a
                   @ r
                   (let {
                      f1 :: Data.Functor.Identity.Identity
                              (Data.Either.Either Syntax.TypeError b)
                            -> Data.Functor.Identity.Identity
                                 (Data.Either.Either Syntax.TypeError a)
                      = Data.Functor.Identity.$fFunctorIdentity_$cfmap
                          @ (Data.Either.Either Syntax.TypeError b)
                          @ (Data.Either.Either Syntax.TypeError a)
                          (Data.Either.$fApplicativeEither_$cfmap
                             @ Syntax.TypeError
                             @ b
                             @ a
                             (\ (ds :: b) -> eta))
                    } in
                    (\ (x :: Control.Monad.Trans.Except.ExceptT
                               Syntax.TypeError Data.Functor.Identity.Identity b) ->
                     f1
                       x `cast`
                       (Control.Monad.Trans.Except.N:ExceptT[0]
                            <Syntax.TypeError>_N <Data.Functor.Identity.Identity>_R <b>_N))
                      `cast`
                    (<Control.Monad.Trans.Except.ExceptT
                        Syntax.TypeError Data.Functor.Identity.Identity b>_R
                     ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                   <Syntax.TypeError>_N
                                   <Data.Functor.Identity.Identity>_R
                                   <a>_N)))) -}
302c7dc09baf24e5a9ae025e2636913a
  $s$fApplicativeFreshMT_$s$fFunctorReaderT_$cfmap ::
    (a -> b)
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Syntax.TypeError Data.Functor.Identity.Identity)
         a
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Syntax.TypeError Data.Functor.Identity.Identity)
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U)><C(S),1*C1(U)><L,U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ r @ a @ b (f :: a -> b) ->
                 Control.Monad.Trans.Reader.mapReaderT
                   @ *
                   @ *
                   @ (Control.Monad.Trans.Except.ExceptT
                        Syntax.TypeError Data.Functor.Identity.Identity)
                   @ a
                   @ (Control.Monad.Trans.Except.ExceptT
                        Syntax.TypeError Data.Functor.Identity.Identity)
                   @ b
                   @ r
                   (let {
                      f1 :: Data.Functor.Identity.Identity
                              (Data.Either.Either Syntax.TypeError a)
                            -> Data.Functor.Identity.Identity
                                 (Data.Either.Either Syntax.TypeError b)
                      = Data.Functor.Identity.$fFunctorIdentity_$cfmap
                          @ (Data.Either.Either Syntax.TypeError a)
                          @ (Data.Either.Either Syntax.TypeError b)
                          (Data.Either.$fApplicativeEither_$cfmap
                             @ Syntax.TypeError
                             @ a
                             @ b
                             f)
                    } in
                    (\ (x :: Control.Monad.Trans.Except.ExceptT
                               Syntax.TypeError Data.Functor.Identity.Identity a) ->
                     f1
                       x `cast`
                       (Control.Monad.Trans.Except.N:ExceptT[0]
                            <Syntax.TypeError>_N <Data.Functor.Identity.Identity>_R <a>_N))
                      `cast`
                    (<Control.Monad.Trans.Except.ExceptT
                        Syntax.TypeError Data.Functor.Identity.Identity a>_R
                     ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                   <Syntax.TypeError>_N
                                   <Data.Functor.Identity.Identity>_R
                                   <b>_N)))) -}
45c548232694ffaa6c47499271fc6bb5
  $s$fApplicativeFreshMT_$s$fMonadReaderT ::
    GHC.Base.Monad
      (Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Syntax.TypeError Data.Functor.Identity.Identity))
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ r.
                  @ (Control.Monad.Trans.Reader.ReaderT
                       r
                       (Control.Monad.Trans.Except.ExceptT
                          Syntax.TypeError Data.Functor.Identity.Identity))
                  (StaticCheck.$s$fApplicativeFreshMT_$s$fMonadReaderT_$cp1Monad @ r)
                  (StaticCheck.$s$fApplicativeFreshMT_$s$fMonadReaderT_$c>>= @ r)
                  (StaticCheck.$s$fApplicativeFreshMT_$s$fMonadReaderT_$c>> @ r)
                  (StaticCheck.$s$fApplicativeFreshMT_$s$fApplicativeReaderT_$cpure
                     @ r)
                  (StaticCheck.$s$fApplicativeFreshMT_$s$fMonadReaderT_$cfail @ r) -}
7122c8927448649d9bb0c7ff3f09aee7
  $s$fApplicativeFreshMT_$s$fMonadReaderT_$c>> ::
    Control.Monad.Trans.Reader.ReaderT
      r
      (Control.Monad.Trans.Except.ExceptT
         Syntax.TypeError Data.Functor.Identity.Identity)
      a
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Syntax.TypeError Data.Functor.Identity.Identity)
         b
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Syntax.TypeError Data.Functor.Identity.Identity)
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,1*C1(U)><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ r
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.Reader.ReaderT
                            r
                            (Control.Monad.Trans.Except.ExceptT
                               Syntax.TypeError Data.Functor.Identity.Identity)
                            a)
                   (k :: Control.Monad.Trans.Reader.ReaderT
                           r
                           (Control.Monad.Trans.Except.ExceptT
                              Syntax.TypeError Data.Functor.Identity.Identity)
                           b) ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (r
                      -> Control.Monad.Trans.Except.ExceptT
                           Syntax.TypeError Data.Functor.Identity.Identity b)
                   @ (Control.Monad.Trans.Reader.ReaderT
                        r
                        (Control.Monad.Trans.Except.ExceptT
                           Syntax.TypeError Data.Functor.Identity.Identity)
                        b)
                   (\ (tpl :: r
                              -> Control.Monad.Trans.Except.ExceptT
                                   Syntax.TypeError Data.Functor.Identity.Identity b) ->
                    tpl)
                     `cast`
                   (<r
                     -> Control.Monad.Trans.Except.ExceptT
                          Syntax.TypeError Data.Functor.Identity.Identity b>_R
                    ->_R Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                  <*>_N
                                  <r>_R
                                  <Control.Monad.Trans.Except.ExceptT
                                     Syntax.TypeError Data.Functor.Identity.Identity>_R
                                  <b>_N))
                   (\ (r1 :: r) ->
                    GHC.Base.$
                      @ 'GHC.Types.PtrRepLifted
                      @ (Data.Functor.Identity.Identity
                           (Data.Either.Either Syntax.TypeError b))
                      @ (Control.Monad.Trans.Except.ExceptT
                           Syntax.TypeError Data.Functor.Identity.Identity b)
                      (\ (tpl :: Data.Functor.Identity.Identity
                                   (Data.Either.Either Syntax.TypeError b)) ->
                       tpl)
                        `cast`
                      (<Data.Functor.Identity.Identity
                          (Data.Either.Either Syntax.TypeError b)>_R
                       ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                     <Syntax.TypeError>_N <Data.Functor.Identity.Identity>_R <b>_N))
                      (Data.Functor.Identity.$fMonadIdentity_$c>>=
                         @ (Data.Either.Either Syntax.TypeError a)
                         @ (Data.Either.Either Syntax.TypeError b)
                         (Control.Monad.Trans.Reader.runReaderT
                            @ r
                            @ *
                            @ (Control.Monad.Trans.Except.ExceptT
                                 Syntax.TypeError Data.Functor.Identity.Identity)
                            @ a
                            m1
                            r1)
                           `cast`
                         (Control.Monad.Trans.Except.N:ExceptT[0]
                              <Syntax.TypeError>_N <Data.Functor.Identity.Identity>_R <a>_N)
                         (\ (a1 :: Data.Either.Either Syntax.TypeError a)[OneShot] ->
                          case a1 of wild {
                            Data.Either.Left e1
                            -> Data.Functor.Identity.$fApplicativeIdentity_$cpure
                                 @ (Data.Either.Either Syntax.TypeError b)
                                 (Data.Either.Left @ Syntax.TypeError @ b e1)
                            Data.Either.Right x
                            -> (Control.Monad.Trans.Reader.runReaderT
                                  @ r
                                  @ *
                                  @ (Control.Monad.Trans.Except.ExceptT
                                       Syntax.TypeError Data.Functor.Identity.Identity)
                                  @ b
                                  k
                                  r1)
                                 `cast`
                               (Control.Monad.Trans.Except.N:ExceptT[0]
                                    <Syntax.TypeError>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <b>_N) })))) -}
9e351bb0f3622017954861cf8e7fe977
  $s$fApplicativeFreshMT_$s$fMonadReaderT_$c>>= ::
    Control.Monad.Trans.Reader.ReaderT
      r
      (Control.Monad.Trans.Except.ExceptT
         Syntax.TypeError Data.Functor.Identity.Identity)
      a
    -> (a
        -> Control.Monad.Trans.Reader.ReaderT
             r
             (Control.Monad.Trans.Except.ExceptT
                Syntax.TypeError Data.Functor.Identity.Identity)
             b)
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Syntax.TypeError Data.Functor.Identity.Identity)
         b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,1*C1(C1(U))><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ r
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.Reader.ReaderT
                            r
                            (Control.Monad.Trans.Except.ExceptT
                               Syntax.TypeError Data.Functor.Identity.Identity)
                            a)
                   (k :: a
                         -> Control.Monad.Trans.Reader.ReaderT
                              r
                              (Control.Monad.Trans.Except.ExceptT
                                 Syntax.TypeError Data.Functor.Identity.Identity)
                              b) ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (r
                      -> Control.Monad.Trans.Except.ExceptT
                           Syntax.TypeError Data.Functor.Identity.Identity b)
                   @ (Control.Monad.Trans.Reader.ReaderT
                        r
                        (Control.Monad.Trans.Except.ExceptT
                           Syntax.TypeError Data.Functor.Identity.Identity)
                        b)
                   (\ (tpl :: r
                              -> Control.Monad.Trans.Except.ExceptT
                                   Syntax.TypeError Data.Functor.Identity.Identity b) ->
                    tpl)
                     `cast`
                   (<r
                     -> Control.Monad.Trans.Except.ExceptT
                          Syntax.TypeError Data.Functor.Identity.Identity b>_R
                    ->_R Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                  <*>_N
                                  <r>_R
                                  <Control.Monad.Trans.Except.ExceptT
                                     Syntax.TypeError Data.Functor.Identity.Identity>_R
                                  <b>_N))
                   (\ (r1 :: r) ->
                    GHC.Base.$
                      @ 'GHC.Types.PtrRepLifted
                      @ (Data.Functor.Identity.Identity
                           (Data.Either.Either Syntax.TypeError b))
                      @ (Control.Monad.Trans.Except.ExceptT
                           Syntax.TypeError Data.Functor.Identity.Identity b)
                      (\ (tpl :: Data.Functor.Identity.Identity
                                   (Data.Either.Either Syntax.TypeError b)) ->
                       tpl)
                        `cast`
                      (<Data.Functor.Identity.Identity
                          (Data.Either.Either Syntax.TypeError b)>_R
                       ->_R Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                     <Syntax.TypeError>_N <Data.Functor.Identity.Identity>_R <b>_N))
                      (Data.Functor.Identity.$fMonadIdentity_$c>>=
                         @ (Data.Either.Either Syntax.TypeError a)
                         @ (Data.Either.Either Syntax.TypeError b)
                         (Control.Monad.Trans.Reader.runReaderT
                            @ r
                            @ *
                            @ (Control.Monad.Trans.Except.ExceptT
                                 Syntax.TypeError Data.Functor.Identity.Identity)
                            @ a
                            m1
                            r1)
                           `cast`
                         (Control.Monad.Trans.Except.N:ExceptT[0]
                              <Syntax.TypeError>_N <Data.Functor.Identity.Identity>_R <a>_N)
                         (\ (a1 :: Data.Either.Either Syntax.TypeError a)[OneShot] ->
                          case a1 of wild {
                            Data.Either.Left e1
                            -> Data.Functor.Identity.$fApplicativeIdentity_$cpure
                                 @ (Data.Either.Either Syntax.TypeError b)
                                 (Data.Either.Left @ Syntax.TypeError @ b e1)
                            Data.Either.Right x
                            -> (Control.Monad.Trans.Reader.runReaderT
                                  @ r
                                  @ *
                                  @ (Control.Monad.Trans.Except.ExceptT
                                       Syntax.TypeError Data.Functor.Identity.Identity)
                                  @ b
                                  (k x)
                                  r1)
                                 `cast`
                               (Control.Monad.Trans.Except.N:ExceptT[0]
                                    <Syntax.TypeError>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <b>_N) })))) -}
2d98f8e58229f783acbcf82391e6c6b0
  $s$fApplicativeFreshMT_$s$fMonadReaderT_$cfail ::
    GHC.Base.String
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Syntax.TypeError Data.Functor.Identity.Identity)
         a
  {- Arity: 2, Strictness: <B,U><B,A>x, Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ r @ a (msg :: GHC.Base.String) (eta :: r) ->
                 case Data.Functor.Identity.$fMonadIdentity_$s$dmfail
                        @ (Data.Either.Either Syntax.TypeError a)
                        msg
                 ret_ty (Control.Monad.Trans.Except.ExceptT
                           Syntax.TypeError Data.Functor.Identity.Identity a)
                 of {})
                  `cast`
                (forall (r :: <*>_N) (a :: <*>_N).
                 <GHC.Base.String>_R
                 ->_R Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                               <*>_N
                               <r>_R
                               <Control.Monad.Trans.Except.ExceptT
                                  Syntax.TypeError Data.Functor.Identity.Identity>_R
                               <a>_N)) -}
82b11e6b8fbae364dfa70db9e9a14bb2
  $s$fApplicativeFreshMT_$s$fMonadReaderT_$cp1Monad ::
    GHC.Base.Applicative
      (Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            Syntax.TypeError Data.Functor.Identity.Identity))
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                StaticCheck.$s$fApplicativeFreshMT_$s$fApplicativeReaderT -}
7fce40a487994b7d8154b44b252156d7
  $s$fFreshFreshMT ::
    Unbound.Generics.LocallyNameless.Fresh.Fresh
      (Unbound.Generics.LocallyNameless.Fresh.FreshMT
         (Control.Monad.Trans.Reader.ReaderT
            Syntax.Ctx
            (Control.Monad.Trans.Except.ExceptT
               Syntax.TypeError Data.Functor.Identity.Identity)))
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Fresh.FreshMT
                       (Control.Monad.Trans.Reader.ReaderT
                          Syntax.Ctx
                          (Control.Monad.Trans.Except.ExceptT
                             Syntax.TypeError Data.Functor.Identity.Identity)))
                  StaticCheck.$s$fFreshFreshMT_$s$fMonadFreshMT
                  (Unbound.Generics.LocallyNameless.Fresh.$fFreshFreshMT_$cfresh
                     @ (Control.Monad.Trans.Reader.ReaderT
                          Syntax.Ctx
                          (Control.Monad.Trans.Except.ExceptT
                             Syntax.TypeError Data.Functor.Identity.Identity))
                     StaticCheck.$s$fApplicativeFreshMT1) -}
2a80c644e3ac6b26474f7603c73a2ee8
  $s$fFreshFreshMT_$s$fMonadFreshMT ::
    GHC.Base.Monad
      (Unbound.Generics.LocallyNameless.Fresh.FreshMT
         (Control.Monad.Trans.Reader.ReaderT
            Syntax.Ctx
            (Control.Monad.Trans.Except.ExceptT
               Syntax.TypeError Data.Functor.Identity.Identity)))
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Unbound.Generics.LocallyNameless.Fresh.FreshMT
                       (Control.Monad.Trans.Reader.ReaderT
                          Syntax.Ctx
                          (Control.Monad.Trans.Except.ExceptT
                             Syntax.TypeError Data.Functor.Identity.Identity)))
                  StaticCheck.$s$fApplicativeFreshMT
                  (Unbound.Generics.LocallyNameless.Fresh.$fMonadFreshMT_$c>>=
                     @ (Control.Monad.Trans.Reader.ReaderT
                          Syntax.Ctx
                          (Control.Monad.Trans.Except.ExceptT
                             Syntax.TypeError Data.Functor.Identity.Identity))
                     StaticCheck.$s$fApplicativeFreshMT1)
                  (Unbound.Generics.LocallyNameless.Fresh.$fMonadFreshMT_$c>>
                     @ (Control.Monad.Trans.Reader.ReaderT
                          Syntax.Ctx
                          (Control.Monad.Trans.Except.ExceptT
                             Syntax.TypeError Data.Functor.Identity.Identity))
                     StaticCheck.$s$fApplicativeFreshMT1)
                  (Unbound.Generics.LocallyNameless.Fresh.$fMonadFreshMT_$creturn
                     @ (Control.Monad.Trans.Reader.ReaderT
                          Syntax.Ctx
                          (Control.Monad.Trans.Except.ExceptT
                             Syntax.TypeError Data.Functor.Identity.Identity))
                     StaticCheck.$s$fApplicativeFreshMT1)
                  (Unbound.Generics.LocallyNameless.Fresh.$fMonadFreshMT_$cfail
                     @ (Control.Monad.Trans.Reader.ReaderT
                          Syntax.Ctx
                          (Control.Monad.Trans.Except.ExceptT
                             Syntax.TypeError Data.Functor.Identity.Identity))
                     StaticCheck.$s$fApplicativeFreshMT1) -}
f3538c16ce67c958bc70031ece845461
  $slookup1 ::
    GHC.Base.String
    -> Data.Map.Base.Map GHC.Base.String a -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
cae6b4dde17f69116d7f4acc4e45bff7
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   StaticCheck.$trModule2
                   StaticCheck.$trModule1) -}
007bcd01c468ca4d00ce4e2992a960a0
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "StaticCheck"#) -}
24450bd9ae5caf377346b0c5e2a398ab
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "main"#) -}
b55891ce0e0f5b769fc68101746fb600
  $winEnv ::
    GHC.Base.String
    -> Syntax.GType
    -> StaticCheck.StaticType a
    -> GHC.Integer.Type.Integer
    -> Control.Monad.Trans.Reader.ReaderT
         Syntax.Ctx
         (Control.Monad.Trans.Except.ExceptT
            Syntax.TypeError Data.Functor.Identity.Identity)
         (a, GHC.Integer.Type.Integer)
  {- Arity: 4, Strictness: <L,U><L,U><L,1*C1(U)><L,U>, Inline: [0],
     Unfolding: (\ @ a
                   (ww :: GHC.Base.String)
                   (ww1 :: Syntax.GType)
                   (w :: StaticCheck.StaticType a)
                   (w1 :: GHC.Integer.Type.Integer) ->
                 let {
                   eta3 :: Control.Monad.Trans.Reader.ReaderT
                             Syntax.Ctx
                             (Control.Monad.Trans.Except.ExceptT
                                Syntax.TypeError Data.Functor.Identity.Identity)
                             (a, GHC.Integer.Type.Integer)
                   = w `cast`
                     (Trans
                          (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0] <Control.Monad.Trans.Reader.ReaderT
                                                                                  Syntax.Ctx
                                                                                  (Control.Monad.Trans.Except.ExceptT
                                                                                     Syntax.TypeError
                                                                                     Data.Functor.Identity.Identity)>_N <a>_N)
                          (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <GHC.Integer.Type.Integer>_N
                               <Control.Monad.Trans.Reader.ReaderT
                                  Syntax.Ctx
                                  (Control.Monad.Trans.Except.ExceptT
                                     Syntax.TypeError Data.Functor.Identity.Identity)>_R
                               <a>_N))
                       w1
                 } in
                 (\ (eta4 :: Syntax.Ctx) ->
                  eta3
                    `cast`
                  (Control.Monad.Trans.Reader.N:ReaderT[0]
                       <*>_N
                       <Syntax.Ctx>_R
                       <Control.Monad.Trans.Except.ExceptT
                          Syntax.TypeError Data.Functor.Identity.Identity>_R
                       <(a, GHC.Integer.Type.Integer)>_N)
                    (case eta4 of wild { Syntax.Ctx ds ds1 ->
                     Syntax.Ctx
                       ds
                       (Gamma.$sinsert_$sgo10
                          @ Syntax.GType
                          ww
                          ww1
                          (Gamma.$sdelete_$sgo10
                             @ Syntax.GType
                             ww
                             ds1 `cast` (Syntax.N:Gamma[0])))
                         `cast`
                       (Sym (Syntax.N:Gamma[0])) }))
                   `cast`
                 (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                           <*>_N
                           <Syntax.Ctx>_R
                           <Control.Monad.Trans.Except.ExceptT
                              Syntax.TypeError Data.Functor.Identity.Identity>_R
                           <(a, GHC.Integer.Type.Integer)>_N))) -}
1d396ffd0685e18382cde0a24d1c9c5f
  $wlookupVar ::
    GHC.Base.String
    -> GHC.Integer.Type.Integer
    -> Syntax.Gamma
    -> Control.Monad.Trans.Except.ExceptT
         Syntax.TypeError
         Data.Functor.Identity.Identity
         (Syntax.GType, GHC.Integer.Type.Integer)
  {- Arity: 3, Strictness: <S,1*U><L,U><S,1*U>, Inline: [0],
     Unfolding: (\ (w :: GHC.Base.String)
                   (w1 :: GHC.Integer.Type.Integer)
                   (ww :: Syntax.Gamma) ->
                 case StaticCheck.$slookup1
                        @ Syntax.GType
                        w
                        ww `cast` (Syntax.N:Gamma[0]) of wild {
                   GHC.Base.Nothing
                   -> (Data.Either.Left
                         @ Syntax.TypeError
                         @ (Syntax.GType, GHC.Integer.Type.Integer)
                         (Syntax.NotInScope
                            (Data.Map.Base.$fShowMap_$cshow
                               @ [GHC.Types.Char]
                               @ Syntax.GType
                               GHC.Show.$fShow[]_$s$fShow[]1
                               Syntax.$fShowGType
                               ww `cast` (Syntax.N:Gamma[0]))))
                        `cast`
                      (Trans
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <Data.Either.Either
                                        Syntax.TypeError
                                        (Syntax.GType, GHC.Integer.Type.Integer)>_R))
                           (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                     <Syntax.TypeError>_N
                                     <Data.Functor.Identity.Identity>_R
                                     <(Syntax.GType, GHC.Integer.Type.Integer)>_N)))
                   GHC.Base.Just e
                   -> (Data.Either.Right
                         @ Syntax.TypeError
                         @ (Syntax.GType, GHC.Integer.Type.Integer)
                         (e, w1))
                        `cast`
                      (Trans
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <Data.Either.Either
                                        Syntax.TypeError
                                        (Syntax.GType, GHC.Integer.Type.Integer)>_R))
                           (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                     <Syntax.TypeError>_N
                                     <Data.Functor.Identity.Identity>_R
                                     <(Syntax.GType, GHC.Integer.Type.Integer)>_N))) }) -}
7b7944838753cc5e3938300b9833ef05
  $wrunStatic ::
    Syntax.Ctx
    -> Syntax.Term -> Data.Either.Either Syntax.TypeError Syntax.GType
  {- Arity: 2, Strictness: <L,U><S,1*U>, Inline: [0],
     Unfolding: (\ (w :: Syntax.Ctx) (ww :: Syntax.Term) ->
                 case (((StaticCheck.checkStatic ww)
                          `cast`
                        (Trans
                             (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0] <Control.Monad.Trans.Reader.ReaderT
                                                                                     Syntax.Ctx
                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                        Syntax.TypeError
                                                                                        Data.Functor.Identity.Identity)>_N <Syntax.GType>_N)
                             (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                  <GHC.Integer.Type.Integer>_N
                                  <Control.Monad.Trans.Reader.ReaderT
                                     Syntax.Ctx
                                     (Control.Monad.Trans.Except.ExceptT
                                        Syntax.TypeError Data.Functor.Identity.Identity)>_R
                                  <Syntax.GType>_N))
                          Unbound.Generics.LocallyNameless.Fresh.runFreshM1)
                         `cast`
                       (Control.Monad.Trans.Reader.N:ReaderT[0]
                            <*>_N
                            <Syntax.Ctx>_R
                            <Control.Monad.Trans.Except.ExceptT
                               Syntax.TypeError Data.Functor.Identity.Identity>_R
                            <(Syntax.GType, GHC.Integer.Type.Integer)>_N)
                         w)
                        `cast`
                      (Trans
                           (Control.Monad.Trans.Except.N:ExceptT[0]
                                <Syntax.TypeError>_N
                                <Data.Functor.Identity.Identity>_R
                                <(Syntax.GType, GHC.Integer.Type.Integer)>_N)
                           (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   Syntax.TypeError
                                   (Syntax.GType, GHC.Integer.Type.Integer)>_R)) of wild {
                   Data.Either.Left e1
                   -> Data.Either.Left @ Syntax.TypeError @ Syntax.GType e1
                   Data.Either.Right x
                   -> Data.Either.Right
                        @ Syntax.TypeError
                        @ Syntax.GType
                        (case x of wild1 { (,) a1 ds1 -> a1 }) }) -}
173e448f47d5b684e8b5fa2415f8d04c
  type StaticType =
    Unbound.Generics.LocallyNameless.Fresh.FreshMT
      (Control.Monad.Trans.Reader.ReaderT
         Syntax.Ctx
         (Control.Monad.Trans.Except.ExceptT
            Syntax.TypeError Data.Functor.Identity.Identity))
    :: * -> *
c89faafa98982b41ab151d2e7adf9ba4
  checkStatic :: Syntax.Term -> StaticCheck.StaticType Syntax.GType
  {- Arity: 1, Strictness: <S,1*U> -}
4e4eb3348d64bbbfa55eeb828e2c999f
  getLabel :: Syntax.GType -> Lattice.GLabel
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Syntax.GType) ->
                 case ds of wild {
                   Syntax.TyBool l -> l Syntax.TyArr ds1 ds2 l -> l }) -}
f9664f55e8b6bbd7763f96e5804f338c
  gradJoin ::
    Syntax.GType -> Syntax.GType -> StaticCheck.StaticType Syntax.GType
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
0d8d59da3f50b81771fde1b69ffbc26a
  gradMeet ::
    Syntax.GType -> Syntax.GType -> StaticCheck.StaticType Syntax.GType
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
e919bafecc6c7f145d1f9c5427169c55
  inEnv ::
    (GHC.Base.String, Syntax.GType)
    -> StaticCheck.StaticType a -> StaticCheck.StaticType a
  {- Arity: 3, Strictness: <S,1*U(U,U)><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                StaticCheck.inEnv1
                  `cast`
                (forall (a :: <*>_N).
                 <(GHC.Base.String, Syntax.GType)>_R
                 ->_R <StaticCheck.StaticType a>_R
                 ->_R Trans
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <GHC.Integer.Type.Integer>_N
                                    <Control.Monad.Trans.Reader.ReaderT
                                       Syntax.Ctx
                                       (Control.Monad.Trans.Except.ExceptT
                                          Syntax.TypeError Data.Functor.Identity.Identity)>_R
                                    <a>_N))
                          (Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                        Syntax.Ctx
                                                                                        (Control.Monad.Trans.Except.ExceptT
                                                                                           Syntax.TypeError
                                                                                           Data.Functor.Identity.Identity)>_N <a>_N)) -}
c1f73eb23aa6cf7fe53a31a44254e2f6
  inEnv1 ::
    (GHC.Base.String, Syntax.GType)
    -> StaticCheck.StaticType a
    -> GHC.Integer.Type.Integer
    -> Control.Monad.Trans.Reader.ReaderT
         Syntax.Ctx
         (Control.Monad.Trans.Except.ExceptT
            Syntax.TypeError Data.Functor.Identity.Identity)
         (a, GHC.Integer.Type.Integer)
  {- Arity: 3, Strictness: <S,1*U(U,U)><L,1*C1(U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: (GHC.Base.String, Syntax.GType))
                   (w1 :: StaticCheck.StaticType a)
                   (w2 :: GHC.Integer.Type.Integer) ->
                 case w of ww { (,) ww1 ww2 ->
                 StaticCheck.$winEnv @ a ww1 ww2 w1 w2 }) -}
09da40d8dac0d7d16c474e22ff59dfb6
  isGradSubTypeOf :: Syntax.GType -> Syntax.GType -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
7667d2f355a68b074cfc4d998474fb6d
  lookupVar :: GHC.Base.String -> StaticCheck.StaticType Syntax.GType
  {- Arity: 3, Strictness: <S,1*U><L,U><S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (0, True, True)
                StaticCheck.lookupVar1
                  `cast`
                (<GHC.Base.String>_R
                 ->_R Trans
                          (<GHC.Integer.Type.Integer>_R
                           ->_R Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                         <*>_N
                                         <Syntax.Ctx>_R
                                         <Control.Monad.Trans.Except.ExceptT
                                            Syntax.TypeError Data.Functor.Identity.Identity>_R
                                         <(Syntax.GType, GHC.Integer.Type.Integer)>_N))
                          (Trans
                               (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                         <GHC.Integer.Type.Integer>_N
                                         <Control.Monad.Trans.Reader.ReaderT
                                            Syntax.Ctx
                                            (Control.Monad.Trans.Except.ExceptT
                                               Syntax.TypeError Data.Functor.Identity.Identity)>_R
                                         <Syntax.GType>_N))
                               (Sym (Unbound.Generics.LocallyNameless.Fresh.N:FreshMT[0]) <Control.Monad.Trans.Reader.ReaderT
                                                                                             Syntax.Ctx
                                                                                             (Control.Monad.Trans.Except.ExceptT
                                                                                                Syntax.TypeError
                                                                                                Data.Functor.Identity.Identity)>_N <Syntax.GType>_N))) -}
b90db0a0d2b37fca1ace1f4fe395d10b
  lookupVar1 ::
    GHC.Base.String
    -> GHC.Integer.Type.Integer
    -> Syntax.Ctx
    -> Control.Monad.Trans.Except.ExceptT
         Syntax.TypeError
         Data.Functor.Identity.Identity
         (Syntax.GType, GHC.Integer.Type.Integer)
  {- Arity: 3, Strictness: <S,1*U><L,U><S(LS),1*U(A,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Base.String)
                   (w1 :: GHC.Integer.Type.Integer)
                   (w2 :: Syntax.Ctx) ->
                 case w2 of ww { Syntax.Ctx ww1 ww2 ->
                 StaticCheck.$wlookupVar w w1 ww2 }) -}
1ea98f83fd51b2a91d65ce2270b737e6
  runOverFile ::
    Syntax.Ctx
    -> [(GHC.Base.String, Syntax.Term)]
    -> Data.Either.Either Syntax.TypeError Syntax.Ctx
  {- Arity: 2, Strictness: <L,U(U,U)><S,1*U> -}
dd70b8dc2739185fa7e1bbe504af8b29
  runStatic ::
    Syntax.Ctx
    -> Syntax.Binding
    -> Data.Either.Either Syntax.TypeError Syntax.GType
  {- Arity: 2, Strictness: <L,U><S(LS),1*U(A,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Syntax.Ctx) (w1 :: Syntax.Binding) ->
                 case w1 of ww { (,) ww1 ww2 -> StaticCheck.$wrunStatic w ww2 }) -}
09a980f1659af5e428a41ae88f25a4b6
  setLabel :: Syntax.GType -> Lattice.GLabel -> Syntax.GType
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Syntax.GType) (l' :: Lattice.GLabel) ->
                 case ds of wild {
                   Syntax.TyBool ds1 -> Syntax.TyBool l'
                   Syntax.TyArr x y ds1 -> Syntax.TyArr x y l' }) -}
"SPEC/StaticCheck $fApplicativeExceptT @ Identity _" [ALWAYS] forall @ e
                                                                     ($dMonad :: GHC.Base.Monad
                                                                                   Data.Functor.Identity.Identity)
                                                                     ($dFunctor :: GHC.Base.Functor
                                                                                     Data.Functor.Identity.Identity)
  Control.Monad.Trans.Except.$fApplicativeExceptT @ Data.Functor.Identity.Identity
                                                  @ e
                                                  $dFunctor
                                                  $dMonad
  = StaticCheck.$s$fApplicativeExceptT @ e
"SPEC/StaticCheck $fApplicativeExceptT_$cpure @ Identity _" [ALWAYS] forall @ e
                                                                            ($dMonad :: GHC.Base.Monad
                                                                                          Data.Functor.Identity.Identity)
                                                                            ($dFunctor :: GHC.Base.Functor
                                                                                            Data.Functor.Identity.Identity)
  Control.Monad.Trans.Except.$fApplicativeExceptT_$cpure @ Data.Functor.Identity.Identity
                                                         @ e
                                                         $dFunctor
                                                         $dMonad
  = StaticCheck.$s$fApplicativeExceptT_$s$fApplicativeExceptT_$cpure
      @ e
"SPEC/StaticCheck $fApplicativeFreshMT @ (ReaderT
                                           Ctx (ExceptT TypeError Identity))" [ALWAYS] forall ($dMonad :: GHC.Base.Monad
                                                                                                                                                              (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                 Syntax.Ctx
                                                                                                                                                                 (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                    Syntax.TypeError
                                                                                                                                                                    Data.Functor.Identity.Identity)))
  Unbound.Generics.LocallyNameless.Fresh.$fApplicativeFreshMT @ (Control.Monad.Trans.Reader.ReaderT
                                                                   Syntax.Ctx
                                                                   (Control.Monad.Trans.Except.ExceptT
                                                                      Syntax.TypeError
                                                                      Data.Functor.Identity.Identity))
                                                              $dMonad
  = StaticCheck.$s$fApplicativeFreshMT
"SPEC/StaticCheck $fApplicativeFreshMT_$cp1Applicative @ (ReaderT
                                                           Ctx (ExceptT TypeError Identity))" [ALWAYS] forall ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                              (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                                                                 Syntax.Ctx
                                                                                                                                                                                                 (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                                    Syntax.TypeError
                                                                                                                                                                                                    Data.Functor.Identity.Identity)))
  Unbound.Generics.LocallyNameless.Fresh.$fApplicativeFreshMT_$cp1Applicative @ (Control.Monad.Trans.Reader.ReaderT
                                                                                   Syntax.Ctx
                                                                                   (Control.Monad.Trans.Except.ExceptT
                                                                                      Syntax.TypeError
                                                                                      Data.Functor.Identity.Identity))
                                                                              $dMonad
  = StaticCheck.$s$fApplicativeFreshMT_$s$fApplicativeFreshMT_$cp1Applicative
"SPEC/StaticCheck $fApplicativeReaderT @ (ExceptT
                                           TypeError Identity) _" [ALWAYS] forall @ r
                                                                                                                                    ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                        (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                           Syntax.TypeError
                                                                                                                                                           Data.Functor.Identity.Identity))
  Control.Monad.Trans.Reader.$fApplicativeReaderT @ (Control.Monad.Trans.Except.ExceptT
                                                       Syntax.TypeError
                                                       Data.Functor.Identity.Identity)
                                                  @ r
                                                  $dApplicative
  = StaticCheck.$s$fApplicativeFreshMT_$s$fApplicativeReaderT @ r
"SPEC/StaticCheck $fApplicativeReaderT_$c<*> @ (ExceptT
                                                 TypeError Identity) _" [ALWAYS] forall @ r
                                                                                                                                                ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                    (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                       Syntax.TypeError
                                                                                                                                                                       Data.Functor.Identity.Identity))
  Control.Monad.Trans.Reader.$fApplicativeReaderT_$c<*> @ (Control.Monad.Trans.Except.ExceptT
                                                             Syntax.TypeError
                                                             Data.Functor.Identity.Identity)
                                                        @ r
                                                        $dApplicative
  = StaticCheck.$s$fApplicativeFreshMT_$s$fApplicativeReaderT_$c<*>
      @ r
"SPEC/StaticCheck $fApplicativeReaderT_$cp1Applicative @ (ExceptT
                                                           TypeError Identity) _" [ALWAYS] forall @ r
                                                                                                                                                                    ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                                        (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                                           Syntax.TypeError
                                                                                                                                                                                           Data.Functor.Identity.Identity))
  Control.Monad.Trans.Reader.$fApplicativeReaderT_$cp1Applicative @ (Control.Monad.Trans.Except.ExceptT
                                                                       Syntax.TypeError
                                                                       Data.Functor.Identity.Identity)
                                                                  @ r
                                                                  $dApplicative
  = StaticCheck.$s$fApplicativeFreshMT_$s$fApplicativeReaderT_$cp1Applicative
      @ r
"SPEC/StaticCheck $fApplicativeReaderT_$cpure @ (ExceptT
                                                  TypeError Identity) _" [ALWAYS] forall @ r
                                                                                                                                                  ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                      (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                                         Syntax.TypeError
                                                                                                                                                                         Data.Functor.Identity.Identity))
  Control.Monad.Trans.Reader.$fApplicativeReaderT_$cpure @ (Control.Monad.Trans.Except.ExceptT
                                                              Syntax.TypeError
                                                              Data.Functor.Identity.Identity)
                                                         @ r
                                                         $dApplicative
  = StaticCheck.$s$fApplicativeFreshMT_$s$fApplicativeReaderT_$cpure
      @ r
"SPEC/StaticCheck $fFreshFreshMT @ (ReaderT
                                     Ctx (ExceptT TypeError Identity))" [ALWAYS] forall ($dMonad :: GHC.Base.Monad
                                                                                                                                                  (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                     Syntax.Ctx
                                                                                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                        Syntax.TypeError
                                                                                                                                                        Data.Functor.Identity.Identity)))
  Unbound.Generics.LocallyNameless.Fresh.$fFreshFreshMT @ (Control.Monad.Trans.Reader.ReaderT
                                                             Syntax.Ctx
                                                             (Control.Monad.Trans.Except.ExceptT
                                                                Syntax.TypeError
                                                                Data.Functor.Identity.Identity))
                                                        $dMonad
  = StaticCheck.$s$fFreshFreshMT
"SPEC/StaticCheck $fFunctorFreshMT @ (ReaderT
                                       Ctx (ExceptT TypeError Identity))" [ALWAYS] forall ($dFunctor :: GHC.Base.Functor
                                                                                                                                                        (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                           Syntax.Ctx
                                                                                                                                                           (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                              Syntax.TypeError
                                                                                                                                                              Data.Functor.Identity.Identity)))
  Unbound.Generics.LocallyNameless.Fresh.$fFunctorFreshMT @ (Control.Monad.Trans.Reader.ReaderT
                                                               Syntax.Ctx
                                                               (Control.Monad.Trans.Except.ExceptT
                                                                  Syntax.TypeError
                                                                  Data.Functor.Identity.Identity))
                                                          $dFunctor
  = StaticCheck.$s$fApplicativeFreshMT_$s$fFunctorFreshMT
"SPEC/StaticCheck $fFunctorReaderT @ (ExceptT TypeError Identity) _" [ALWAYS] forall @ r
                                                                                     ($dFunctor :: GHC.Base.Functor
                                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                                        Syntax.TypeError
                                                                                                        Data.Functor.Identity.Identity))
  Control.Monad.Trans.Reader.$fFunctorReaderT @ (Control.Monad.Trans.Except.ExceptT
                                                   Syntax.TypeError Data.Functor.Identity.Identity)
                                              @ r
                                              $dFunctor
  = StaticCheck.$s$fApplicativeFreshMT_$s$fFunctorReaderT @ r
"SPEC/StaticCheck $fFunctorReaderT_$c<$ @ (ExceptT
                                            TypeError Identity) _" [ALWAYS] forall @ r
                                                                                                                                      ($dFunctor :: GHC.Base.Functor
                                                                                                                                                      (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                         Syntax.TypeError
                                                                                                                                                         Data.Functor.Identity.Identity))
  Control.Monad.Trans.Reader.$fFunctorReaderT_$c<$ @ (Control.Monad.Trans.Except.ExceptT
                                                        Syntax.TypeError
                                                        Data.Functor.Identity.Identity)
                                                   @ r
                                                   $dFunctor
  = StaticCheck.$s$fApplicativeFreshMT_$s$fFunctorReaderT_$c<$ @ r
"SPEC/StaticCheck $fFunctorReaderT_$cfmap @ (ExceptT
                                              TypeError Identity) _" [ALWAYS] forall @ r
                                                                                                                                          ($dFunctor :: GHC.Base.Functor
                                                                                                                                                          (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                             Syntax.TypeError
                                                                                                                                                             Data.Functor.Identity.Identity))
  Control.Monad.Trans.Reader.$fFunctorReaderT_$cfmap @ (Control.Monad.Trans.Except.ExceptT
                                                          Syntax.TypeError
                                                          Data.Functor.Identity.Identity)
                                                     @ r
                                                     $dFunctor
  = StaticCheck.$s$fApplicativeFreshMT_$s$fFunctorReaderT_$cfmap @ r
"SPEC/StaticCheck $fMonadFreshMT @ (ReaderT
                                     Ctx (ExceptT TypeError Identity))" [ALWAYS] forall ($dMonad :: GHC.Base.Monad
                                                                                                                                                  (Control.Monad.Trans.Reader.ReaderT
                                                                                                                                                     Syntax.Ctx
                                                                                                                                                     (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                        Syntax.TypeError
                                                                                                                                                        Data.Functor.Identity.Identity)))
  Unbound.Generics.LocallyNameless.Fresh.$fMonadFreshMT @ (Control.Monad.Trans.Reader.ReaderT
                                                             Syntax.Ctx
                                                             (Control.Monad.Trans.Except.ExceptT
                                                                Syntax.TypeError
                                                                Data.Functor.Identity.Identity))
                                                        $dMonad
  = StaticCheck.$s$fFreshFreshMT_$s$fMonadFreshMT
"SPEC/StaticCheck $fMonadReaderT @ (ExceptT TypeError Identity) _" [ALWAYS] forall @ r
                                                                                   ($dMonad :: GHC.Base.Monad
                                                                                                 (Control.Monad.Trans.Except.ExceptT
                                                                                                    Syntax.TypeError
                                                                                                    Data.Functor.Identity.Identity))
  Control.Monad.Trans.Reader.$fMonadReaderT @ (Control.Monad.Trans.Except.ExceptT
                                                 Syntax.TypeError Data.Functor.Identity.Identity)
                                            @ r
                                            $dMonad
  = StaticCheck.$s$fApplicativeFreshMT_$s$fMonadReaderT @ r
"SPEC/StaticCheck $fMonadReaderT_$c>> @ (ExceptT
                                          TypeError Identity) _" [ALWAYS] forall @ r
                                                                                                                                  ($dMonad :: GHC.Base.Monad
                                                                                                                                                (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                   Syntax.TypeError
                                                                                                                                                   Data.Functor.Identity.Identity))
  Control.Monad.Trans.Reader.$fMonadReaderT_$c>> @ (Control.Monad.Trans.Except.ExceptT
                                                      Syntax.TypeError
                                                      Data.Functor.Identity.Identity)
                                                 @ r
                                                 $dMonad
  = StaticCheck.$s$fApplicativeFreshMT_$s$fMonadReaderT_$c>> @ r
"SPEC/StaticCheck $fMonadReaderT_$c>>= @ (ExceptT
                                           TypeError Identity) _" [ALWAYS] forall @ r
                                                                                                                                    ($dMonad :: GHC.Base.Monad
                                                                                                                                                  (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                     Syntax.TypeError
                                                                                                                                                     Data.Functor.Identity.Identity))
  Control.Monad.Trans.Reader.$fMonadReaderT_$c>>= @ (Control.Monad.Trans.Except.ExceptT
                                                       Syntax.TypeError
                                                       Data.Functor.Identity.Identity)
                                                  @ r
                                                  $dMonad
  = StaticCheck.$s$fApplicativeFreshMT_$s$fMonadReaderT_$c>>= @ r
"SPEC/StaticCheck $fMonadReaderT_$cfail @ (ExceptT
                                            TypeError Identity) _" [ALWAYS] forall @ r
                                                                                                                                      ($dMonad :: GHC.Base.Monad
                                                                                                                                                    (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                       Syntax.TypeError
                                                                                                                                                       Data.Functor.Identity.Identity))
  Control.Monad.Trans.Reader.$fMonadReaderT_$cfail @ (Control.Monad.Trans.Except.ExceptT
                                                        Syntax.TypeError
                                                        Data.Functor.Identity.Identity)
                                                   @ r
                                                   $dMonad
  = StaticCheck.$s$fApplicativeFreshMT_$s$fMonadReaderT_$cfail @ r
"SPEC/StaticCheck $fMonadReaderT_$cp1Monad @ (ExceptT
                                               TypeError Identity) _" [ALWAYS] forall @ r
                                                                                                                                            ($dMonad :: GHC.Base.Monad
                                                                                                                                                          (Control.Monad.Trans.Except.ExceptT
                                                                                                                                                             Syntax.TypeError
                                                                                                                                                             Data.Functor.Identity.Identity))
  Control.Monad.Trans.Reader.$fMonadReaderT_$cp1Monad @ (Control.Monad.Trans.Except.ExceptT
                                                           Syntax.TypeError
                                                           Data.Functor.Identity.Identity)
                                                      @ r
                                                      $dMonad
  = StaticCheck.$s$fApplicativeFreshMT_$s$fMonadReaderT_$cp1Monad @ r
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

